c
c ----------------------------------------------------------------------------
c
c	An example of a driver program that calls the 
c	Neighbourhood algorithm routines to search a 
c	parameter space. See HTML manual for more details.
c					
c                                               M. Sambridge, RSES, ANU.
c						Last updated Sept. 1999.
c
c ----------------------------------------------------------------------------
c
	Program hv_na

c					MEMORY AND ARRAY SIZES
c
c					The NA routines use the
c					following include file to define
c					all parameters controlling
c					memory required by the arrays.
c
c					A description of each parameter,
c					indicating which ones should be 
c					changed to fit your application
c					can be found in 'na_param.inc' 
c
c	include 	'na_param.inc'
c
c					INPUT AND OUTPUT
c       Input files:
c                   na.in       	Contains options for Neighbourhood 
c					algorithm (see HTML manual)
c
c       Output files:
c                   na.sum      	summary of results
c
c                   na.nad      	NAD (NA direct access file of models)
c
c                   sobol.coeff 	initializing data used for
c                               	quasi-random sequences
c					(This is output for reference only)
c
c       Comments:
c                The NAD file is a direct access compact format file
c                containing all models generated by the neighbourhood
c                algorithm. (NAD files can be read in by multi-dimensional
c                integration program NA-Bayes and plot program S-plot.)
c
c		 Logical units 30-40 are reserved for use by NA subroutines
c		 The user specific routines should not use these values
c		 for logical units.
c		 The NA routines also write to LU 6 as standard out.
c
c ----------------------------------------------------------------------------
c
c					Call NA routine to do the work		

	integer 	n_iter

	common /rfi_com/observed_data, predicted_data, sd,
     &                  weight,
     &                  ndata,
     &                  nwave, ref_model, lu_mod, fname, n_iter, fs


	n_iter = 0

	call na



	stop
	end
c
c ----------------------------------------------------------------------------
c
c	THE FOLLOWING IS AN EXAMPLE OF THE THREE ROUTINES,
c	CALLED BY THE NA ROUTINES, WHICH THE USER MUST SUPPLY. 
c
c	user_init - defines parametrization and can be
c		    used to perform any user initialization 
c		    (e.g. reading in data etc.) 
c
c	forward   - performs forward modelling on an input model
c		    and returns the misfit value of that model.
c
c	writemodels - a routine called after the NA has completed.
c		      All models and misfits are supplied 
c		      to the routine and here the user may write  
c		      then out in their own format.
c		      (Note that the NA routines only write the
c		       models out in a direct access NAD file.
c		       see HTML manual for details.)
c
c	THIS EXAMPLE IS FOR A CRUSTAL RECEIVER FUNCTION INVERSION PROBLEM. 
c
c		In this case the routines perform the following tasks:
c		read in data, define the parametrization,
c		calculate synthetics, define a misfit function and
c		write out various information to ascii files.
c
c	See HTMl manual for more details. An explanation of
c	calling the sequence and meaning is attached to each routine. 
c
c
c       This code is based on work by T. Shibutani (RCEP, DPRI, KYOTO UNIV.)
c	who wrote the receiver function routines.
c
c	Modifications by M. Sambridge (RSES, ANU) for use 
c	with a Neighbourhood algorithm.
c
c						M. Sambridge (RSES, ANU)
c
c-------------------------------------------------------------------------
c
c	user_init - performs all user specific initialization tasks. 
c		    In this case for receiver receiver function inversion.
c
c	Input: - iproc		:processor id (for MPI compilation).
c                                This allows the root node (id=0) to 
c				 emit debug iformation during user_init. 
c				 For serial option id=0.
c
c	Output:
c	      nd		:Number of dimensions in parameter space
c	      ranges(2,nd)	:bounds on parameter space
c	      scales(nd+1)	:scale factors in parameter space
c
c	Comments:
c		 The scale factors are used to transform the model
c		 parameter space into a non-dimensional space. They 
c		 must be provided by the user to put each parameter
c		 on an equal footing.  In the transformation
c		 the i-th parameter becomes,
c		
c		 xi_after = (xi_before-ranges(1,i))/scales(i+1).
c
c		 Note that scales(i+1) contains the scale factor for 
c		 the i-th parameter. The value of scales(1) can be used 
c		 as a shortcut to indicate common choices for scale 
c		 factors. If scales(1) = 0 then all scale factors are
c		 reset to 1; if scales(1) = -1 then the scale factors 
c		 are reset to the parameter range, i.e.,
c
c		 scales(i+1) = ranges(2,i)-ranges(1,i)
c
c		 and for any other value the scale factors are left unchanged.
c		 Note that if scales(1) is set to 0 or -1 then there is
c		 no need to fill up the scales array.
c
c		 This routine is only set up for a 6 layer 24 dimensional 
c		 receiver function problem. 
c
c				M. Sambridge, RSES (ANU), April 1998. 
c
c-------------------------------------------------------------------------
c
	subroutine user_init(nd,ranges,scales)

c						initialize receiver
c						function forward modelling
        include 'hv_subs/hv_param.inc'
c
	real*4		ranges(2,*),
     &			scales(*)
c
	real*4		observed_data(maxdata,maxwave),
     &			sd(maxdata,maxwave),
     &                  predicted_data(maxdata,maxwave),
     &			weight(maxwave)

	integer		ndata(maxwave), istatus, n_iter, nwave

	logical		verbose,debug,timing,summary
	logical		lroot
c
	character*200	chars,
     &			kname
	character*100	fname(maxwave)

	character*100	ref_model
c						Info and Logical unit common 
c						blocks used by NA routines
c
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary

        common /NAMPI/iproc,nproc,lroot

	common /rfi_com/observed_data, predicted_data, sd, 
     &                  weight, 
     &                  ndata,
     &                  nwave, ref_model, lu_mod, fname, n_iter, fs


c
c		Set up logical units 
c						LU's for standard input and 
c						output
        lu_rfi  = 15
        lu_out = 6
c
c
c		Set up logical units for rfi files
c
c						LU for input of velocity 
c						model
	lu_vel = 11
c						LU for output of model 
c						parameters
	lu_mod = 12
c

c	out_folder = "../../"
c	data_folder = "../data/"

	call system("rm ../../full_list.txt")
        call system("rm -r ../../models/*")
        call system("rm -r ../../out_models/*")
	
c^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

c						Open rfi files
	open(lu_rfi,file='../data/hv_files/hv.in',status='old')
	read(lu_rfi,*)
	read(lu_rfi,*)
	read(lu_rfi,*)

	if(lroot)write(lu_out,*)
	if(lroot)write(lu_out,*)' User routines output'  
	if(lroot)write(lu_out,*)
	if(lroot)write(lu_out,*)' Opening rfi files...'
	read(lu_rfi,'(a)') chars
	lw=lofw(chars)
        write(kname,'("../data/hv_files/NA_MDL/",a,a1)') chars(1:lw),char(0)
	if(lroot)write(lu_out,*)
	if(lroot)write(lu_out,*) '* Now open ... ',kname(1:lw+17)
	open(lu_vel,file=kname,status='old')
c
	read(lu_rfi,'(a)') chars
	lw=lofw(chars)
        write(kname,'("../../",a,a1)') chars(1:lw),char(0)
	if(lroot)write(lu_out,*)
	if(lroot)write(lu_out,*) '* Now open ... ',kname(1:lw+17)
	open(lu_mod, file=kname, status='unknown')
c
c						Read in velocity model 
c						and ranges of the parameters
	call read_vmodelNA
     &	     (lu_vel, ranges, scales, nd, q_alpha, q_beta ) 
	close(lu_vel)
c
c
c						Read in ORFs in SAC format
	read(lu_rfi,*) nwave
c
	do iw=1,nwave
	  	read(lu_rfi,'(a)') chars
	  	lw=lofw(chars)
          	write(fname(iw),'("../data/hv_files/OBS/",a,a1)') chars(1:lw),char(0)
	  	if(lroot)write(lu_out,*)
	  	if(lroot)write(lu_out,*) '* Read in data from ',fname(iw)(1:lw+30)

		read(lu_rfi,*) weight(iw)
	 	if(lroot)write(lu_out,*) '* Weight =',weight(iw)
	  	if(lroot)write(lu_out,*)' '


		read(lu_rfi,'(a)') chars
                lw=lofw(chars)
		write(ref_model, '("../data/hv_files/REF_MDL/",a,a1)') chars(1:lw),char(0)
		write(*,*) ref_model
	

		open(666, file=fname(iw), status='old', IOSTAT=istatus)
		open(17, file="../../periods.txt", status="replace")
		read(666,*)
		do i=1, 300
			read(666,*,IOSTAT=istatus) T, observed_data(i,iw), sd(i,iw)
			if (istatus .lt. 0) then
				goto 90
			end if
			write(17,*) T
		end do
		close(17)
	
  90	continue
	ndata = i-1
	end do
	
	close(lu_rfi)


        if(lroot)write(lu_out,*)
c	if(lroot)write(lu_out,101)

 100    format(1x,60("-")//)
 101    format(/1x,60("-")/)

		
	return
	end
c
c-------------------------------------------------------------------------
c
c	forward - performs forward modelling for user supplied problem.
c		  In this case it calculates predicted receiver function
c		  for a single model and calculates the misfit measure
c		  between observation and prediction.
c
c	Input: 
c	      nd		:Number of dimensions in parameter space
c	      model(nd)		:input velocity model
c
c	Output:
c	      lppd		:negative log(ppd)
c
c	Comments:
c		 This routine allows the user to perform the forward 
c		 modelling and define an a posterior probability density
c		 function using the resulting mismatch with the observed
c		 data. Note that the output quanity is the negative
c		 natural log of the ppd. This is equivalent to the 
c		 misfit function in most problems. 
c
c				M. Sambridge, RSES (ANU), April 1998. 
c
c-------------------------------------------------------------------------
c FFFFF
	subroutine forward(nd,model,lppd, nmdl)

c						initialize receiver
c						function forward modelling
        include 'hv_subs/hv_param.inc'

	real*4		lppd
	real*4		misfitval
	real*4		rough, tot_rough
	real*4		model(nd)

	real*4		rmodel(max_nd)
c
	real*4		observed_data(maxdata,maxwave),
     &                  predicted_data(maxdata,maxwave),
     &			sd(maxdata,maxwave), 
     &			weight(maxwave),
     &			vs(maxlayer),
     &			thick_i(200), vs_i(200), vp_i(200), rho_i(200),
     &			e, f, g, h,l,m
c
	integer		ndata(maxwave), nlayers, n_layers_input, j, istatus


	logical		verbose,debug,timing,summary

	character*100	fname(maxwave)
	character*30	line_E
	character*70	line

	character*20	modelcode
	integer		iproc, n_iter
	character*10	iproc_s, n_iter_s
	character*200	outmodel
	character*200	pred_ell_file, model_file	
	character*100	ref_model
c
c						Info and Logical unit common 
c						blocks used by NA routines
c
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary

	common /NAMPI/iproc,nproc,lroot

	common /rfi_com/observed_data, predicted_data, sd, 
     &                  weight, 
     &                  ndata,
     &                  nwave, ref_model, lu_mod, fname, n_iter, fs
c
c		Set up logical units 
c						LU's for standard input and 
c						output
        do j=1,nd
           rmodel(j) = dble(model(j))
        end do





c	read reference model for deeper crust and mantle
	open(15, file=trim(ref_model), status="old",  IOSTAT = istatus)
	
	do i=1,12
		read(15,*, IOSTAT = istatus) line
		
	end do
	j = 1
	do i=15, 2000	
		read(15,*, IOSTAT = istatus) thick_i(j), vp_i(j),  vs_i(j),  rho_i(j), e,f,g,h,l,m
		if (istatus .lt. 0) goto 91
		n_layers_input = j
		j = j + 1
		
	end do
   91	continue
	close(15)





c                                               Perform forward modelling
c                                               on model `rmodel'.
c
c------------------------------------
c---	Define model code
c------------------------------------
	write(n_iter_s,'(I10)'), n_iter
	write(iproc_s, '(I10)'), iproc

	modelcode = trim(n_iter_s)//"_"//adjustl(iproc_s)
c	lw=lofw(modelcode)

	n_iter = n_iter + 1


	call forward_modelling(
     &       rmodel, nd, ndata, nwave, fs,
     &       predicted_data, vs, thick_i, vp_i,
     &       vs_i,  rho_i, n_layers_input, modelcode)

c                                               Calculate misfit function


        call calcmisfit(
     &       predicted_data, observed_data, sd, ndata,
     &       weight, nwave, misfitval )

c	Calculate roughness (if needed a regularization of the models)
	nlayers = nd/2
	rough = 0.0
	do i=2,nlayers-1
		rough = rough + ( vs(i-1) - 2*vs(i) + vs(i+1)  )**2 
	end do


	A = 0.0      ! Scaling factor of the roughness
	tot_rough = A*rough*ndata(1)
	lppd = misfitval + tot_rough  ! Cost function

	write(*,*) 'Misfit: ', misfitval, " Roughness: ",  tot_rough, " Cost: ", lppd


c	================ OUTPUT ==========================
c	Saving the proposed model together with theoretical ellipticity curve and misfit and cost values

 	pred_ell_file =  trim("../../models/" // adjustl(modelcode)) // "/predicted_ellipticity"
	model_file = trim("../../models/" // adjustl(modelcode)) // "/model.d"
	 
	outmodel = "../../out_models/model_" // adjustl(modelcode)
	
	open(666, file = outmodel, form = "formatted", status="replace")
	write(666,*)"mft: ", misfitval, "rgh: ", tot_rough, "cost: ", lppd, "A: ", A 
	write(666,*) "Predicted values: "

	open(110, file = pred_ell_file,form = "formatted", status="old",IOSTAT=istatus)
	do i=1,300
		read(110, '(A)', IOSTAT=istatus) line_E
		if (istatus .lt. 0) then
			goto 13
		end if
		write(666,*) line_E
	end do
	
  13	continue
	close(110)

	write(666,*) "!"
	write(666,*) "model:"
	

	open(111,file=model_file, form='formatted', status='old', IOSTAT=istatus)
	do i=1,12	
		read(111, '(A)')
	end do
	do i=12, nlines + 1000	
		read(111, '(A)', IOSTAT=istatus) line
		if (istatus .lt. 0) then
			goto 12
		end if
		write(666,*) line
	end do

  12	continue

	write(666,*) "#--------------------------------------------------------------------------"


	close(666)	
c	close(111)

	
	return
	end
c
c-------------------------------------------------------------------------
c
c	writemodels - user supplied routine to write out models produced
c		      by Neighbourhood algorithm in user's own format.
c
c	Input: 
c	      nd		  :number of dimensions in parameter space
c	      ntot		  :number of models generated by NA 
c	      models(nd,ntot)     :models generated by NA
c	      misfit 		  :array of model misfits (-lppd's)
c	      ns1  		  :initial sample size used by NA
c	      ns2  		  :normal sample size used by NA
c	      itmax  		  :number of iterations
c	      nh_max  		  :maximum length of nad file header 
c
c	Output:         
c	      nh  		  :length of nad file header 
c	      header(nh)  	  :character string containing nad file header
c
c	Comments:
c	         This routine allows the user to write out the models
c		 produced by the NA in their own format. The three 
c		 parameters ns1, ns2 and itmax define the samples sizes
c		 and number of iterations taken by the NA. Initially ns1
c		 random samples are generated, and then itmax sets of ns2
c		 models are generated and so ntot = ns1 + ns2*itmax. 
c
c		 The user may if they wish write their own information 
c		 into the `user reserved' part of NAD file header.
c		 (See example below for details).
c
c				M. Sambridge, RSES (ANU), Oct 1999. 
c
c-------------------------------------------------------------------------
c
	subroutine writemodels
     &             (nd, ntot, models, misfit, ns1, ns2, itmax,
     &              nh_max, nh, header)

        include 'hv_subs/hv_param.inc'

c						NA variables and arrays
	real*4		models(nd,*)
	real*4		misfit(ntot)
	real*4		mfitmin
	real*4		mfitminc
	real*4		mfitmean

        character*(*)   header

	logical		verbose,debug,timing,summary

c						Receiver function variables
c						and arrays
	real*4		rmodel(max_nd)

	real*4		observed_data(maxdata,maxwave),
     &                  predicted_data(maxdata,maxwave),
     &			sd(maxdata,maxwave),
     &			weight(maxwave)
	integer		ndata(maxwave)

	character*100	fname(maxwave)
	integer		n_iter, istatus
	character*100	filename
	character*60	line
	character*100	ref_model
c
c						Info and Logical unit common 
c						block used by NA routines
c
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary


c						Receiver function 
c						common block

	common /rfi_com/observed_data, predicted_data, sd, 
     &                  weight, 
     &                  ndata,
     &                  nwave, ref_model, lu_mod, fname, n_iter, fs


c====================	FINALISING OUTPUT FILE =============================================
c	Here it puts together all the output files in a unique file

        call system("ls -f ../../out_models/model_* | wc -l > ../../out_models/list_of_files")
        call system("ls -tr ../../out_models/model_* >> ../../out_models/list_of_files")

        open(211, file = "../../out_models/list_of_files", form='formatted')
        read(211,*) n_files
	call system("rm ../../full_list.txt") 
        open(131, file = "../../full_list.txt", form='formatted',status="new")

        do i=1,n_files
                read(211,'(A)') filename
                open(191, file=filename,
     &          form='formatted', access='sequential', status="old", IOSTAT=istatus)
                do k = 1,1000
                        read(191,'(A)', IOSTAT=istatus) line
			if (istatus .lt. 0) then 
				goto 15
			else
				write(131, '(A60)') line
                	end if
		end do
  15		continue 
                close(191)
        end do
        close(131)


c        call system("rm -r ../../models/*")
c        call system("rm -r ../../out_models/*")




c==================================================================

 
 
  801      format( 'iteration:',i5,',  misfit: min=',f10.5,
     &             ', mean=',f10.5,', minc=',f10.5 )

	return
	end



